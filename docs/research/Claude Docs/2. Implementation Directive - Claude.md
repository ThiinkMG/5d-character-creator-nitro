# 5D Character Creator: Implementation Directive for Cursor Agent

## Mission Statement

Transform 5D Character Creator from a "chat-based brainstorming tool" into an **"AI-Augmented Word Processor"** using the proven formula:

> **Visual Wiki (UI)** + **Vector Search (Architecture)** + **Just-in-Time Injection (Workflow)**

---

## Priority Implementation: The Three Pillars

### Pillar 1: @ Mention System (Progressive Formalization)
**Why:** Users hate filling out forms before writing. Let them write first, organize later.

### Pillar 2: Context Sidecar (Dynamic Reference)
**Why:** The relevant data should "follow" the user's cursor‚Äîzero searching required.

### Pillar 3: Just-in-Time Context Injection
**Why:** Don't dump the entire World Bible into AI prompts. Retrieve only what's relevant to the current scene.

---

## Implementation Task 1: @ Mention Entity System

### User Story
> As a writer, I want to type `@CharacterName` in the chat/editor and have the system either recognize an existing character OR offer to create a new one, so I never break my creative flow.

### Technical Specification

#### 1.1 Mention Detection Hook
```typescript
// hooks/useMentionDetection.ts

interface EntityMention {
  name: string;
  position: { start: number; end: number };
  exists: boolean;
  entity?: Entity;
  suggestions?: Entity[]; // Fuzzy matches
}

export const useMentionDetection = (text: string) => {
  const { characters, worlds, locations } = useStore();
  
  const detectMentions = useCallback((input: string): EntityMention[] => {
    const mentionRegex = /@(\w+[\w\s]*?)(?=\s|$|[.,!?])/g;
    const mentions: EntityMention[] = [];
    let match;
    
    while ((match = mentionRegex.exec(input)) !== null) {
      const name = match[1].trim();
      
      // Exact match
      const exactMatch = findEntityByName(name, [...characters, ...worlds, ...locations]);
      
      // Fuzzy suggestions if no exact match
      const suggestions = exactMatch ? [] : fuzzySearchEntities(name, 5);
      
      mentions.push({
        name,
        position: { start: match.index, end: match.index + match[0].length },
        exists: !!exactMatch,
        entity: exactMatch,
        suggestions
      });
    }
    
    return mentions;
  }, [characters, worlds, locations]);
  
  return { mentions: detectMentions(text) };
};
```

#### 1.2 Mention Popup Component
```typescript
// components/MentionPopup.tsx

interface MentionPopupProps {
  mention: EntityMention;
  position: { x: number; y: number };
  onSelectEntity: (entity: Entity) => void;
  onCreateNew: (name: string, type: EntityType) => void;
  onDismiss: () => void;
}

export const MentionPopup: React.FC<MentionPopupProps> = ({
  mention,
  position,
  onSelectEntity,
  onCreateNew,
  onDismiss
}) => {
  if (mention.exists && mention.entity) {
    // Show quick preview card
    return (
      <div className="mention-popup glassmorphism" style={{ top: position.y, left: position.x }}>
        <EntityQuickCard entity={mention.entity} />
        <div className="actions">
          <button onClick={() => onSelectEntity(mention.entity!)}>
            Insert Reference
          </button>
          <button onClick={onDismiss}>Dismiss</button>
        </div>
      </div>
    );
  }
  
  // Show create/suggest options
  return (
    <div className="mention-popup glassmorphism" style={{ top: position.y, left: position.x }}>
      <p className="text-sm text-muted">"{mention.name}" not found</p>
      
      {mention.suggestions && mention.suggestions.length > 0 && (
        <div className="suggestions">
          <p className="text-xs">Did you mean:</p>
          {mention.suggestions.map(entity => (
            <button key={entity.id} onClick={() => onSelectEntity(entity)}>
              {entity.name} ({entity.type})
            </button>
          ))}
        </div>
      )}
      
      <div className="create-new">
        <p className="text-xs">Create new:</p>
        <button onClick={() => onCreateNew(mention.name, 'character')}>
          + Character
        </button>
        <button onClick={() => onCreateNew(mention.name, 'location')}>
          + Location
        </button>
        <button onClick={() => onCreateNew(mention.name, 'item')}>
          + Item
        </button>
      </div>
    </div>
  );
};
```

#### 1.3 Quick Entity Creation (Stub)
```typescript
// store/actions/createEntityStub.ts

export const createEntityStub = (name: string, type: EntityType): Entity => {
  const stub: Partial<Character5D> = {
    id: generateId(),
    foundation: {
      name,
      role: 'supporting', // Default
      archetype: '',
      concept: `[Auto-created from @mention. Flesh out later.]`
    },
    meta: {
      completionPercentage: 5, // Minimal
      createdAt: new Date(),
      updatedAt: new Date(),
      tags: ['stub', 'needs-development']
    }
  };
  
  // Add to store
  useStore.getState().addCharacter(stub as Character5D);
  
  // Queue for Completion Assistant
  useStore.getState().addToDevQueue(stub.id);
  
  return stub as Entity;
};
```

---

## Implementation Task 2: Context Sidecar

### User Story
> As a writer, when I'm typing about "The Northern War," I want the relevant wiki entry to automatically appear in a sidebar without me searching for it.

### Technical Specification

#### 2.1 Entity Detection in Active Text
```typescript
// hooks/useContextSidecar.ts

interface SidecarContext {
  detectedEntities: Entity[];
  pinnedEntities: Entity[];
  isLoading: boolean;
}

export const useContextSidecar = (activeText: string): SidecarContext => {
  const [detectedEntities, setDetectedEntities] = useState<Entity[]>([]);
  const [pinnedEntities, setPinnedEntities] = useState<Entity[]>([]);
  const { characters, worlds, locations, lore } = useStore();
  
  // Debounced detection to avoid excessive processing
  const debouncedText = useDebounce(activeText, 300);
  
  useEffect(() => {
    if (!debouncedText) {
      setDetectedEntities([]);
      return;
    }
    
    // Build entity name index for fast lookup
    const allEntities = [...characters, ...worlds, ...locations, ...lore];
    const entityNames = allEntities.map(e => ({
      entity: e,
      nameVariants: [e.name, ...(e.aliases || [])].map(n => n.toLowerCase())
    }));
    
    // Scan text for entity mentions
    const textLower = debouncedText.toLowerCase();
    const detected = entityNames
      .filter(({ nameVariants }) => 
        nameVariants.some(name => textLower.includes(name))
      )
      .map(({ entity }) => entity)
      .slice(0, 5); // Limit to top 5
    
    setDetectedEntities(detected);
  }, [debouncedText, characters, worlds, locations, lore]);
  
  const pinEntity = (entity: Entity) => {
    setPinnedEntities(prev => [...prev, entity]);
  };
  
  const unpinEntity = (entityId: string) => {
    setPinnedEntities(prev => prev.filter(e => e.id !== entityId));
  };
  
  return {
    detectedEntities,
    pinnedEntities,
    pinEntity,
    unpinEntity,
    isLoading: false
  };
};
```

#### 2.2 Sidecar UI Component
```typescript
// components/ContextSidecar.tsx

interface ContextSidecarProps {
  activeText: string;
  onEntityClick: (entity: Entity) => void;
}

export const ContextSidecar: React.FC<ContextSidecarProps> = ({
  activeText,
  onEntityClick
}) => {
  const { detectedEntities, pinnedEntities, pinEntity, unpinEntity } = useContextSidecar(activeText);
  
  return (
    <aside className="context-sidecar glassmorphism w-80 h-full overflow-y-auto">
      {/* Pinned Entities */}
      {pinnedEntities.length > 0 && (
        <section className="pinned-section">
          <h3 className="text-xs uppercase tracking-wide text-muted mb-2">
            üìå Pinned
          </h3>
          {pinnedEntities.map(entity => (
            <EntityContextCard
              key={entity.id}
              entity={entity}
              isPinned
              onUnpin={() => unpinEntity(entity.id)}
              onClick={() => onEntityClick(entity)}
            />
          ))}
        </section>
      )}
      
      {/* Auto-Detected Entities */}
      <section className="detected-section">
        <h3 className="text-xs uppercase tracking-wide text-muted mb-2">
          üîç Detected in Text
        </h3>
        {detectedEntities.length === 0 ? (
          <p className="text-sm text-muted italic">
            Start typing to auto-detect entities...
          </p>
        ) : (
          detectedEntities.map(entity => (
            <EntityContextCard
              key={entity.id}
              entity={entity}
              isPinned={false}
              onPin={() => pinEntity(entity)}
              onClick={() => onEntityClick(entity)}
            />
          ))
        )}
      </section>
    </aside>
  );
};

// Compact card for sidecar display
const EntityContextCard: React.FC<{
  entity: Entity;
  isPinned: boolean;
  onPin?: () => void;
  onUnpin?: () => void;
  onClick: () => void;
}> = ({ entity, isPinned, onPin, onUnpin, onClick }) => {
  return (
    <div 
      className="entity-context-card glassmorphism p-3 mb-2 cursor-pointer hover:border-accent"
      onClick={onClick}
    >
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          {entity.media?.avatar && (
            <img src={entity.media.avatar} className="w-8 h-8 rounded-full" />
          )}
          <div>
            <h4 className="font-medium text-sm">{entity.name}</h4>
            <span className="text-xs text-muted capitalize">{entity.type}</span>
          </div>
        </div>
        <button 
          onClick={(e) => { e.stopPropagation(); isPinned ? onUnpin?.() : onPin?.(); }}
          className="text-muted hover:text-accent"
        >
          {isPinned ? 'üìå' : 'üìç'}
        </button>
      </div>
      
      {/* Quick stats based on entity type */}
      {entity.type === 'character' && (
        <div className="mt-2 text-xs text-muted">
          <span>{(entity as Character5D).foundation?.role}</span>
          {(entity as Character5D).foundation?.archetype && (
            <span> ‚Ä¢ {(entity as Character5D).foundation.archetype}</span>
          )}
        </div>
      )}
    </div>
  );
};
```

---

## Implementation Task 3: Just-in-Time Context Injection

### User Story
> As a writer using the AI chat, I want the system to automatically inject only the relevant character/world info into the AI prompt based on what I'm currently writing about, so the AI doesn't get confused with irrelevant information.

### Technical Specification

#### 3.1 Context Injection Engine
```typescript
// lib/contextInjection.ts

interface ContextInjectionConfig {
  mode: ChatMode;
  maxTokens: number;
  priorityOrder: string[];
  includeFields: Record<EntityType, string[]>;
}

const MODE_CONFIGS: Record<ChatMode, ContextInjectionConfig> = {
  chat_with_character: {
    mode: 'chat_with_character',
    maxTokens: 2000,
    priorityOrder: ['voiceProfile', 'personality', 'currentRelationships'],
    includeFields: {
      character: ['name', 'voiceProfile', 'personality', 'relationships'],
      world: ['tone', 'genre'],
      location: []
    }
  },
  workshop: {
    mode: 'workshop',
    maxTokens: 4000,
    priorityOrder: ['canonicalFacts', 'arc', 'backstory', 'personality'],
    includeFields: {
      character: ['foundation', 'personality', 'backstory', 'arc', 'relationships', 'canonicalFacts'],
      world: ['lore', 'magicSystem', 'factions'],
      location: ['description', 'significance']
    }
  },
  worldbuilding: {
    mode: 'worldbuilding',
    maxTokens: 3000,
    priorityOrder: ['genre', 'tone', 'magicSystem', 'factions'],
    includeFields: {
      character: ['name', 'role'],
      world: ['name', 'genre', 'tone', 'magicSystem', 'factions', 'history'],
      location: ['name', 'type', 'description', 'significance']
    }
  },
  continuity_check: {
    mode: 'continuity_check',
    maxTokens: 5000,
    priorityOrder: ['canonicalFacts', 'timeline'],
    includeFields: {
      character: ['canonicalFacts', 'timeline', 'foundation'],
      world: ['canonicalLore', 'history'],
      location: ['canonicalFacts']
    }
  }
};

export const assembleContextForPrompt = async (
  mode: ChatMode,
  currentText: string,
  linkedEntityIds: string[]
): Promise<string> => {
  const config = MODE_CONFIGS[mode];
  const store = useStore.getState();
  
  // Step 1: Get explicitly linked entities
  const linkedEntities = linkedEntityIds
    .map(id => store.getEntityById(id))
    .filter(Boolean);
  
  // Step 2: Detect entities mentioned in current text
  const detectedNames = extractEntityNames(currentText);
  const detectedEntities = detectedNames
    .map(name => store.findEntityByName(name))
    .filter(Boolean)
    .filter(e => !linkedEntityIds.includes(e.id)); // Avoid duplicates
  
  // Step 3: Combine and prioritize
  const allEntities = [...linkedEntities, ...detectedEntities];
  
  // Step 4: Filter fields based on mode config
  const filteredEntities = allEntities.map(entity => 
    filterEntityFields(entity, config.includeFields[entity.type] || [])
  );
  
  // Step 5: Build context string with token budget
  let contextString = '';
  let currentTokens = 0;
  
  for (const entity of filteredEntities) {
    const entityContext = formatEntityForPrompt(entity);
    const entityTokens = estimateTokens(entityContext);
    
    if (currentTokens + entityTokens > config.maxTokens) {
      break; // Token budget exceeded
    }
    
    contextString += entityContext + '\n\n';
    currentTokens += entityTokens;
  }
  
  return contextString;
};

// Format entity data for injection into AI prompt
const formatEntityForPrompt = (entity: Entity): string => {
  if (entity.type === 'character') {
    const char = entity as Character5D;
    return `
## Character: ${char.foundation.name}
**Role:** ${char.foundation.role}
**Archetype:** ${char.foundation.archetype || 'Not defined'}

${char.voiceProfile ? `### Voice Profile
- Tone: ${char.voiceProfile.tone}
- Patterns: ${char.voiceProfile.speechPatterns?.join(', ')}
- Sample: "${char.voiceProfile.sampleDialogue?.[0] || 'No sample'}"
` : ''}

${char.personality ? `### Personality
- Core Traits: ${char.personality.coreTraits?.join(', ')}
- Flaws: ${char.personality.flaws?.join(', ')}
- Internal Conflict: ${char.personality.internalConflict || 'Not defined'}
` : ''}

${char.canonicalFacts?.length ? `### Canonical Facts (DO NOT CONTRADICT)
${char.canonicalFacts.map(f => `- ${f.fact} [${f.confidence}]`).join('\n')}
` : ''}
`.trim();
  }
  
  // Add formatters for world, location, etc.
  return `## ${entity.type}: ${entity.name}\n${JSON.stringify(entity, null, 2)}`;
};
```

#### 3.2 Integration with Chat API
```typescript
// app/api/chat/route.ts (updated)

export async function POST(req: Request) {
  const { messages, mode, linkedEntityIds, currentText } = await req.json();
  
  // Assemble context using Just-in-Time injection
  const injectedContext = await assembleContextForPrompt(
    mode,
    currentText || messages[messages.length - 1]?.content || '',
    linkedEntityIds || []
  );
  
  // Build system prompt with injected context
  const systemPrompt = buildSystemPrompt(mode, injectedContext);
  
  // Route to appropriate AI provider based on mode
  const provider = getProviderForMode(mode);
  
  // Make API call
  const response = await provider.chat({
    messages: [
      { role: 'system', content: systemPrompt },
      ...messages
    ],
    temperature: getTemperatureForMode(mode),
    max_tokens: getMaxTokensForMode(mode)
  });
  
  return new Response(response.body, {
    headers: { 'Content-Type': 'text/event-stream' }
  });
}

const buildSystemPrompt = (mode: ChatMode, context: string): string => {
  const modeInstructions = {
    chat_with_character: `You are roleplaying as the character described below. Stay in character. Use their voice, mannerisms, and personality. Never break character.`,
    workshop: `You are a creative writing assistant helping develop this character. Ask probing questions. Suggest improvements. Flag potential inconsistencies.`,
    worldbuilding: `You are a worldbuilding consultant. Help expand the world's lore, ensuring internal consistency. Reference established facts.`,
    continuity_check: `You are a continuity editor. Analyze the provided text against the canonical facts. Flag any contradictions or inconsistencies. Be precise and cite your sources.`
  };
  
  return `${modeInstructions[mode]}

## WORLD BIBLE (Reference Material)
${context}

## RULES
- NEVER contradict the canonical facts listed above
- If asked about something not in the World Bible, acknowledge the gap
- Maintain consistency with established tone and genre
`;
};
```

---

## Implementation Task 4: Canonical Facts System

### User Story
> As a writer, I want to mark certain details as "canonical facts" that the AI must never contradict, so I maintain consistency across my story.

### Technical Specification

#### 4.1 Schema Update (already in main doc)
```typescript
interface CanonicalFact {
  id: string;
  category: 'physical' | 'personality' | 'history' | 'relationship' | 'ability' | 'possession' | 'other';
  fact: string;
  establishedIn: string; // Scene/chapter reference
  establishedAt: Date;
  confidence: 'definite' | 'implied' | 'tentative';
}
```

#### 4.2 Quick-Add Canonical Fact UI
```typescript
// components/CanonicalFactAdder.tsx

export const CanonicalFactAdder: React.FC<{
  entityId: string;
  selectedText?: string;
}> = ({ entityId, selectedText }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [fact, setFact] = useState(selectedText || '');
  const [category, setCategory] = useState<CanonicalFact['category']>('other');
  const [source, setSource] = useState('');
  
  const { addCanonicalFact } = useStore();
  
  const handleSubmit = () => {
    addCanonicalFact(entityId, {
      id: generateId(),
      fact,
      category,
      establishedIn: source,
      establishedAt: new Date(),
      confidence: 'definite'
    });
    setIsOpen(false);
    setFact('');
  };
  
  return (
    <>
      <button 
        onClick={() => setIsOpen(true)}
        className="btn-secondary text-sm"
      >
        + Add Canonical Fact
      </button>
      
      {isOpen && (
        <Modal onClose={() => setIsOpen(false)}>
          <h3>Add Canonical Fact</h3>
          <p className="text-sm text-muted mb-4">
            This fact will be included in AI context and flagged if contradicted.
          </p>
          
          <textarea
            value={fact}
            onChange={(e) => setFact(e.target.value)}
            placeholder="e.g., 'Kira is left-handed'"
            className="w-full p-2 mb-2"
          />
          
          <select value={category} onChange={(e) => setCategory(e.target.value as any)}>
            <option value="physical">Physical</option>
            <option value="personality">Personality</option>
            <option value="history">History</option>
            <option value="relationship">Relationship</option>
            <option value="ability">Ability</option>
            <option value="possession">Possession</option>
            <option value="other">Other</option>
          </select>
          
          <input
            type="text"
            value={source}
            onChange={(e) => setSource(e.target.value)}
            placeholder="Where established? (e.g., 'Chapter 3')"
            className="w-full p-2 mt-2"
          />
          
          <div className="flex justify-end gap-2 mt-4">
            <button onClick={() => setIsOpen(false)}>Cancel</button>
            <button onClick={handleSubmit} className="btn-primary">
              Add Fact
            </button>
          </div>
        </Modal>
      )}
    </>
  );
};
```

---

## Phase 1 Checklist (2-3 Weeks)

### Week 1: Schema & Foundation
- [ ] Add `voiceProfile` to Character schema
- [ ] Add `canonicalFacts` array to Character and World schemas
- [ ] Add `aliases` field to entities for @ mention fuzzy matching
- [ ] Update Zustand store with new fields
- [ ] Create migration script for existing data

### Week 2: @ Mention System
- [ ] Implement `useMentionDetection` hook
- [ ] Build `MentionPopup` component
- [ ] Implement `createEntityStub` action
- [ ] Add "Needs Development" queue to Completion tracking
- [ ] Test in Chat Studio input

### Week 3: Context Sidecar
- [ ] Implement `useContextSidecar` hook
- [ ] Build `ContextSidecar` component
- [ ] Build `EntityContextCard` component
- [ ] Add pin/unpin functionality
- [ ] Integrate into Chat Studio layout (split view)

### Week 4: Just-in-Time Injection
- [ ] Implement `assembleContextForPrompt` function
- [ ] Create mode-specific context configs
- [ ] Update chat API route to use context injection
- [ ] Add "Context Preview" debug panel (show what AI sees)
- [ ] Test across all chat modes

---

## Success Metrics

| Metric | Current | Target |
|--------|---------|--------|
| Entity creation friction | High (form-based) | Low (@ mention) |
| Context relevance | Manual linking only | Auto-detection + injection |
| Canon consistency | None | Fact validation layer |
| Token efficiency | Full entity dumps | Mode-optimized selection |

---

## Files to Create/Modify

### New Files
- `hooks/useMentionDetection.ts`
- `hooks/useContextSidecar.ts`
- `components/MentionPopup.tsx`
- `components/ContextSidecar.tsx`
- `components/EntityContextCard.tsx`
- `components/CanonicalFactAdder.tsx`
- `lib/contextInjection.ts`

### Modified Files
- `store/types.ts` (schema updates)
- `store/index.ts` (new actions)
- `app/api/chat/route.ts` (context injection)
- `components/ChatStudio.tsx` (layout for sidecar)

---

*Ready for implementation. Start with Week 1 schema updates.*